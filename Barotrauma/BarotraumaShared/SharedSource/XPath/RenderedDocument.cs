using System.Linq;
using System.Xml;

namespace Barotrauma.XPath;

/// <summary>
/// This is a simple wrapper that is able to handle XmlDocuments and XmlNode/XmlElement interchangeably so the XPath.Elements.Element code doesn't need to worry about the output document.
/// </summary>
public interface IRenderedDocument
{
    RenderedElement CreateElement(string elementTag);
    RenderedElement Append(string comment, XmlElement element);
    void Save();
}

public class RenderedDocument : IRenderedDocument
{
    private readonly XmlDocument _document;
    private readonly string _targetPath;
    private XmlNode _root;

    internal XmlDocument Document => _document;

    public RenderedDocument(PatcherContext context)
    {
        _document = new XmlDocument();
        XmlDeclaration xmlDeclaration = _document.CreateXmlDeclaration("1.0", "UTF-8", null);
        XmlElement root = _document.DocumentElement;
        _document.InsertBefore(xmlDeclaration, root);

        XmlComment comment = _document.CreateComment($"Generated by XPath Patcher {context.Name}");
        _document.InsertBefore(comment, root);
        this._root = root; // Root starts as null
        this._targetPath = context.PatchedContentPath.FullPath;
    }

    internal XmlNode Import(XmlElement element)
    {
        return _document.ImportNode(element, true);
    }

    public RenderedElement CreateElement(string elementTag)
    {
        XmlElement element = _document.CreateElement(elementTag);
        return this.Append(null, element);
    }

    public RenderedElement Append(string comment, XmlElement element)
    {
        XmlNode node = element;
        if (element.OwnerDocument != _document)
        {
            node = this.Import(element);
        }

        // If there isn't already a root element make new element the root.
        if(_root == null)
        {
            if (comment != null)
            {
                XmlComment importedComment = _document.CreateComment(comment);
                _document.AppendChild(importedComment);
            }

            _document.AppendChild(node);
            _root = node;
        }
        else
        {
            if (comment != null)
            {
                XmlComment xmlComment = _document.CreateComment(comment);
                _root.AppendChild(xmlComment);
            }

            _root.AppendChild(node);
        }
        
        return new RenderedElement(this, node);
    }

    public void Save()
    {
        _document.Save(_targetPath);
    }

    public new string ToString() => _document.OuterXml;
}

public class RenderedElement : IRenderedDocument
{
    private readonly RenderedDocument _document;
    private readonly XmlNode _element;

    protected internal RenderedElement(RenderedDocument document, XmlNode element)
    {
        _document = document;
        _element = element;
    }

    public RenderedElement CreateElement(string elementTag)
    {
        XmlElement element = this._document.Document.CreateElement(elementTag);
        return this.Append(null, element);
    }

    public RenderedElement Append(string comment, XmlElement element)
    {
        XmlNode node = element;
        if (element.OwnerDocument != _element.OwnerDocument)
        {
            node = _document.Import(element);
        }

        if (comment != null)
        {
            XmlComment xmlComment = this._document.Document.CreateComment(comment);
            _element.AppendChild(xmlComment);
        }

        _element.AppendChild(node);
        return new RenderedElement(_document, node);
    }

    public void Save()
    {
        _document.Save();
    }
}